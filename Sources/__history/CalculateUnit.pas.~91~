unit CalculateUnit;

interface

uses
  System.StrUtils, System.SysUtils;

type
  TPairedBrackets = Record
    OpeningBracketPos: Integer;
    ClosingBracketPos: Integer
  end;

  TOperands = Record
    LeftOperand: String;
    RigthOperand: String;
    LeftEdge: Integer;
    RightEdge: Integer;
  end;

function CalculateExpression(Expression: String): String;
function CalculateArithmeticExpression(Expression: String): String;
function GetFirstPairedBrackets(Expression: String): TPairedBrackets;
function GetOperands(Expression: String; OperationPos: Integer): TOperands;

implementation

// вычисление результата сложного арифметического выражения
function CalculateExpression(Expression: String): String;
var
  Brackets: TPairedBrackets;
  ExpressionResult: String;
  SubExpression: String;
  ExpressionResultInDouble: Double;
begin
  Brackets := GetFirstPairedBrackets(Expression);

  // если скобки не найдены - вычисляем простое арифметическое выражение
  if (Brackets.OpeningBracketPos = 0) or (Brackets.ClosingBracketPos = 0) then
    Expression := CalculateArithmeticExpression(Expression);

  // пока находятся парные скобки, вычисляем выражения, находящиеся между них
  while (Brackets.OpeningBracketPos > 0) and (Brackets.ClosingBracketPos > 0) do
  begin
    if Brackets.ClosingBracketPos - Brackets.OpeningBracketPos > 1 then // если скобки стоят рядом, то вычислять между ними нечего
    begin
      SubExpression := Copy(Expression, Brackets.OpeningBracketPos + 1, Brackets.ClosingBracketPos - 1); // получаем выражение, находящееся между скобок
      ExpressionResult := CalculateArithmeticExpression(SubExpression); // отправляем на расчёт полученное выражение
    end;
    if ExpressionResult = 'error' then // если выражение не было посчитано - прерываем цикл
      Break;
    Expression := StuffString(Expression, Brackets.OpeningBracketPos, Length(SubExpression) + 1, ExpressionResult); // заменяем в исходном выражении блок со скобками на результат вычисления этого блока
    Brackets := GetFirstPairedBrackets(Expression);
  end;

  // в конечном итоге должно остаться одно число
  if TryStrToFloat(Expression, ExpressionResultInDouble) then
    Result := Expression
  else
    Result := 'error'
end;

// вычисление результата простого арифметического выражения, без скобок
function CalculateArithmeticExpression(Expression: String): String;
const
    Operations = '/*-+';
var
  Operation: Char;
  OperationPos: Integer;
  Operands: TOperands;
  LeftOperand: Double;
  RightOperand: Double;
  ExpressionResult: Double;
begin
  // перебираем по очереди арифметические операции
  for Operation in Operations do
  begin
    OperationPos := Pos(Operation, Expression); // находим позицию знака арифметической операции
    // ищем знаки арифметических операций, при этом операция не может стоять в начале или конце выражения
    while (OperationPos > 1) and (OperationPos < Length(Expression)) do
    begin
      Operands := GetOperands(Expression, OperationPos); // получаем операнды выражения и его границы
      // если не найден один из операндов - выходим из функции
      if (Operands.LeftOperand = '') or (Operands.RigthOperand = '') then
        begin
          Result := 'error';
          Exit
        end;

      LeftOperand := StrToFloat(Operands.LeftOperand);
      RightOperand := StrToFloat(Operands.RigthOperand);

      // проверка деления на ноль
      if (Operation = '/') and (RightOperand = 0) then
      begin
        Result := 'error';
        Exit
      end;

      // вычисляем результат арифметического выражения
      case Operation of
        '/': ExpressionResult := LeftOperand / RightOperand;
        '*': ExpressionResult := LeftOperand * RightOperand;
        '-': ExpressionResult := LeftOperand - RightOperand;
        '+': ExpressionResult := LeftOperand + RightOperand;
      end;

      Expression := StuffString(Expression, Operands.LeftEdge, Operands.RightEdge - Operands.LeftEdge + 1, FloatToStr(ExpressionResult)); // заменяем в исходном выражении блок операции на её результат

      OperationPos := Pos(Operation, Expression);
    end;
  end;

  // в конечном итоге должно остаться одно число
  if TryStrToFloat(Expression, ExpressionResult) then
    Result := Expression
  else
    Result := 'error'
end;

// получаем операнды и границы выражения
function GetOperands(Expression: String; OperationPos: Integer): TOperands;
const
  digits = '0123456789';
var
  LeftOperand: String;
  RightOperand: String;
  LeftEdge: Integer;
  RightEdge: Integer;
  i: Integer;
begin
  LeftOperand := '';
  LeftEdge := 0;
  // собираем число слева от оперции
  for i := OperationPos - 1 downto 1 do
    if Pos(Expression[i], digits) > 0 then
    begin
      LeftOperand := Expression[i] + LeftOperand;
      LeftEdge := i
    end
    else
      Break;

  RightOperand := '';
  RightEdge := 0;
  // собираем число справа от операции
  for i := OperationPos + 1 to Length(Expression) do
    if Pos(Expression[i], digits) > 0 then
    begin
      RightOperand := RightOperand + Expression[i];
      RightEdge := i
    end
    else
      Break;

  Result.LeftOperand := LeftOperand;
  Result.RigthOperand := RightOperand;
  Result.LeftEdge := LeftEdge;
  Result.RightEdge := RightEdge
end;

// получение позиций первой пары скобок, не содержащей внутри другие скобки
function GetFirstPairedBrackets(Expression: String): TPairedBrackets;
const
  ClosingBrackets = ')]}';
var
  OpeningBracketPos: Integer;
  ClosingBracketPos: Integer;
  BracketPos: Integer;
  Bracket: String;
  ClosingBracket: String;
begin
  ClosingBracket := '';
  ClosingBracketPos := Length(Expression) + 1;
  // находим ближайшую закрывающую скобку
  for Bracket in ClosingBrackets do
  begin
    BracketPos := Pos(Bracket, Expression);
    if BracketPos < ClosingBracketPos then
      ClosingBracket := Bracket;
      ClosingBracketPos := BracketPos
  end;

  // если закрывающая скобка найдена - ищем открывающую
  if ClosingBracket <> '' then
  begin
    // находим ближайшую открывающую скобку
    Expression := ReverseString(Expression); // переворачиваем строку
    OpeningBracketPos := Length(Expression) - PosEx(ClosingBracket, Expression, Length(Expression) - ClosingBracketPos + 1) + 1; // в перевёрнутой строке находим ближаюшую закрывающую к уже найденной скобке и вычисляем её позицию в исходной строке
  end
  else
  begin
    OpeningBracketPos := 0;
    ClosingBracketPos := 0
  end;

  Result.OpeningBracketPos := OpeningBracketPos;
  Result.ClosingBracketPos := ClosingBracketPos
end;

end.
